
# README

1.  Все диаграммы, что у меня были на момент 11.12.2025 лежат в папке
    **доступные_материалы**.
2.  Программа лежит в папке **APP**.
3.  В папке **один_файл** лежит программа одним файлом (если вдруг).

## Логины и пароли для разных ролей:

-   **analyst(логин)** --- пароль: `pass1`, роль: `security`
-   **specialist(логин)** --- пароль: `pass2`, роль: `equipment`
-   **manager(логин)** --- пароль: `pass3`, роль: `fraud`



# Проект — соответствие кода UML-диаграмм

Реализация строго соответствует спроектированной объектной модели и является прямой программной реализацией архитектуры, представленной в UML-диаграммах.

Ниже приведён подробный разбор соответствия по слоям архитектуры.

---

## 1. Слой сущностей (Data Models)

На диаграммах (преимущественно Image 1) изображены сущности данных. В коде они реализованы с использованием декоратора `@dataclass`, что является оптимальным способом описания структур данных в Python.

| Класс на диаграмме | Реализация в коде (`main.py`) | Соответствие атрибутов |
|--------------------|-------------------------------|------------------------|
| `RawData`          | `@dataclass class RawData`    | Полное. Поля `id, timestamp, source, attributes` полностью совпадают. |
| `PreparedData`     | `@dataclass class PreparedData` | Полное. Поля `id, timestamp, data_type, features` реализованы. |
| `User`             | `@dataclass class User`       | Полное. Реализованы `user_id, username, role, email`. |
| `Anomaly`          | `@dataclass class Anomaly`    | Полное. Поля `score, severity, description` и связи по ID присутствуют. |
| `Alert`            | `@dataclass class Alert`      | Полное. Статус, сообщение, время и связь с аномалией реализованы. |
| `DetectionSettings`| `@dataclass class DetectionSettings` | Полное. Настройки чувствительности и ID пользователя учтены. |


---

## 2. Слой абстракций и интерфейсов

Диаграммы предполагают использование паттернов "Стратегия" или интерфейсов для обработки данных и детекции. В Python код это реализовано через модуль `abc` (Abstract Base Classes).

- **Абстракция `DataProcessor`**:
  - *Диаграмма:* Интерфейс/абстрактный класс с методом `process()`.
  - *Код:* Класс `DataProcessor` (`abc.ABC`) с абстрактным методом `process`.
  - *Реализация:* Класс `StandardProcessor` наследуется от `DataProcessor` и реализует конкретную логику очистки и нормализации.

- **Абстракция `AnomalyDetector`**:
  - *Диаграмма:* Интерфейс детектора.
  - *Код:* Класс `AnomalyDetector` (`abc.ABC`) определяет контракт методов `train` и `detect`.
  - *Реализация:* Класс `IsolationForestDetector` наследует абстракцию и реализует алгоритм "Изолирующий лес" (через `sklearn` либо заглушку в примере).

- **Абстракция `AlertManager`**:
  - *Диаграмма:* Интерфейс отправки уведомлений.
  - *Код:* Класс `AlertManager` (`abc.ABC`).
  - *Реализация:* `EmailAlertManager` реализует конкретный метод `send_alert`, выводя сообщение в консоль (симуляция email).

---

## 3. Слой хранения и управления (Services)

- **`DataStorage`:**
  - В коде представлен класс `DataStorage`. Он выполняет роль репозитория ("in-memory database"), хранящего списки `raw_data`, `processed_data`, `anomalies`.
  - Методы `add_raw_data`, `add_processed_data`, `get_historical_data` соответствуют операциям, ожидаемым от слоя доступа к данным.

---

## 4. Слой представления (UI / View)


**MainApp (Контроллер/Контекст):**
- Наследуется от `tk.Tk` (как показано на диаграммах наследования UI).
- Реализует композицию: в методе `__init__` создаются экземпляры `DataStorage`, `StandardProcessor`, `IsolationForestDetector`, `EmailAlertManager`. Это соответствует ромбовидным стрелкам (композиция/агрегация) на диаграммах.
- Управляет навигацией через метод `switch_view`.

**View (Абстракция UI):**
- Класс `View(abc.ABC)` определяет структуру для всех экранов.
- Методы `render`, `update`, `stop_update` обеспечивают единый жизненный цикл компонентов интерфейса.

**Конкретные представления:**
- `MainMonitorView`, `HistoricalView`, `AlertsView`, `SettingsView` наследуются от `View`.
- Они реализуют конкретную верстку (Dashboard, графики, таблицы алертов), что соответствует визуальным схемам экранов.

---

## 5. Ключевые алгоритмические связи

В методе `run_monitoring` класса `MainMonitorView` (и в `MainApp`) прослеживается цепочка вызовов, заложенная в диаграмме последовательности:

1. **Генерация данных** (`_generate_mock_data`).
2. **Обработка** (`processor.process`).
3. **Сохранение** (`storage.add_processed_data`).
4. **Детекция** (`detector.detect`).
5. **Алерт** (`alert_manager.send_alert`) при обнаружении аномалии.


---

## Итог

Реализация является точным и полным воплощением представленных UML-диаграмм. Инкапсуляция соблюдена через использование классов. Наследование и полиморфизм реализованы через `abc` и переопределение абстрактных методов. Связи реализованы через хранение ссылок на объекты в атрибутах класса `MainApp`.

---
